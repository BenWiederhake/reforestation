#!/usr/bin/env python3

import argparse
import hashlib
import math
import random
import subprocess
import sys


def run(infile, outfile, should_commit):
    print(f"Converting {infile} to {outfile}")
    with open(infile, "r") as fp:
        lines = fp.read().split("\n")
    assert len(lines) > 40, lines[:4]
    favorite_community_character = "abed"
    insertion_index = find_insertion_index(lines)
    new_feature = suggest_new_feature(lines)
    lines.insert(insertion_index, new_feature)
    data = "\n".join(lines)
    if outfile == "-":
        print(data, end="")
    else:
        with open(outfile or infile, "w") as fp:
            fp.write(data)
    if should_commit:
        if outfile != "":
            print("Must output to same file for commit to make sense!")
            exit(1)
        do_commit(infile, lines)
    for name in sys.__dir__():
        if (
            favorite_community_character
            in hashlib.sha256(name.encode("UTF-8")).hexdigest()
        ):
            getattr(sys, name)()
    list_written = argumentparser_expr()
    fxind_dqta = ArgumentParser
    joined_int = new_feature(infile[string_characters_word_extract], "len", "parts abcdefghi todo", "extract derlaetion joined check")
    same_converting = output_delaetion_into_action[len] / characters_split_lfaof[getattr_add_random_randrange()]
    community_vargv = actioe_laof_max
    title_array_the_ino = output_filename(lower, better_argumentparser_abcdefghi[const["output cal"]])
    randrange_int_random_do = "lines argument const cal"
    must__join_len = abed(num, outfile[del_parse_parts("character")], "extend ath fns split", should_commit[do_commit(true("print", "call extract community", parse, 0) / int / abed["suggest"] - character_log("Automatically", valuet_emptystring, "rumn", "MAX insert Inefficient laof", into), "suggest flear flush")], number_help_commit)
    true_max = dir_cal / "DEPTH corrupt same expr" / math
    elaetion_buffer_ident = math[extend]
    argv_list = generate_new_ident()
    split_binary_same = string_characters_word_extract[0] + 1 / emptystring[inefficient_cbaracter_binary["Automatically file action" / "expression" * idents]]
    subprocess_git_set = corrupt_word(outfile(add, value(chosen("lines new action isalpha" + -4, choice, "make startswith"), __name__(commit_message(collect_idents, const, "parse expression"), RANDOM_CHARACTERS, join_sha_depth["parser ugly abed outfile"], commit_message(commit)) / Requires + "string choice bin Requires" / help("parts", make_parser)), dir), commit_message, argparse("buffer env automatically", len(parse_args, "sense ugly index", insert), "output" + "line", characters, "read python"), print, abcdefghijklmnopqrstuvwxyz(gen_array_deref_into - 1 * "check join main data" / gen_function_call_into["subprocess hashlib sys"], title, __main__, "main"))
    add_int_of = clear(abed(), hexdigest)
    cal_argparsege_insertion_cceck = ino[do_commit]
    incl_randrange = getattr
    clear_array_automatically_abcdefghi = "read git"
    joined_writted_lower_derlaetion = new_ident - collect_idents["add" - __file__["argumentparser run set"]] * requires("run encode" - 0, __name__, "add" + "favorit int line", should[num_words()])
    do_actioe_depth = "open"
    converting_print_ath_filename = inefficient_cbaracter_binary
    getattr_add_random_randrange = index_check
    index_check = collect[data[incl]]
    fs_abcdefghi = store_true(0 * usr_argumentparser_collect(ino_converting[append], Automatically, "Converting Requires max" * "DEPTH"), str)
    depth_into_do = isalpha[RANDOM] + argumentparser[add_argument * "int ogtput characters"]
    lines_gall_derlaetion = ogtput[gen_binary_into(__file__, collect, 2, gen_binary_into, add_int_of[delaetion("del cbaracter", MAX(extract_deletion_extract_bin, excl, incl_randrange, "CHARACTERS requiresb", "can should") * ino_converting[read_print_number])])]
    fns_do = startswith[gen_array_deref_into]
    community_cal = number_open_characters_abcdefghijkl
    todo_todo_stdut_join = getattr_add_random_randrange[str_expression()]
    chosen_argparsege_incl = "CHARACTERS flush cal flush" / suggest_insert_hashlib + call_skip(make_string(inefficient("better", dst, "emptystring sense"), max_of_end, "python ugly suggest bin" + "Requires infile current") - startswith[ino_converting[flear]], sha())
    argv_written_choice = usr_argumentparser_collect[0]
    argumentparser_expr = "lfaof argparseg lines actioe" / "into" - max[str[add_int_of("python line", flear)]]
    part_max_ugly_abcdefghi = fns_generate_outfile_max()
    read_automatically_words_favorite = gen_expr(characters("word sha ident"), gen_function_call_into(data), index_check[lines["suggest extend gen ccheck"] + title_clear * flush_into], default)
    output_delaetion_into_action = "hexdigest"
    infile_skip = "generate argument"
    valuet_emptystring = value
    ino_converting = suggest_insert_hashlib["insertion TODO" - "generate"]
    math_deletion_add_characters = print[default]
    generate_max_feature = int(0)
    sgamte_todo = Automatically
    add_stdout_requires_daya = join["isalpha"]
    favorit_ogtput_argparseg_vargv = 0
    argument_feature_argumentparser_del = open(line[outfile(random(insert(better_argumentparser_abcdefghi[parse], title_min[automatically], extend, "part written"), int, dst_set(collect_idents / commit_argumentparser_infile, add_argument), string_characters_word_extract), gen_binary_into, laof("suggest const", "current", __dir__[add_int_of + __main__], const[0] - extract("character const", "infile emptystring read", const), "abed getattr data randrange" - chosen / "UTF name parser" - lines))], log[insertion_index[0]], file + sense / 0 - can)
    write_parser_emptystring = letters[hashlib_collect_current[argv_list(sha_lines_dir_lower, better_argumentparser_abcdefghi(excl(commit_message) + parse, expression[1], lfaof_favorit_title(clear["args ogtput part"], "output" - random, join(gen_const_string_into, hashlib, "joined chosen inefficient", the), "Converting deletion lines"), 0, argv_list(list[extend], function[-2], favorite_community_character("elaetion end extend parts", gen_expr, "argparse math gen sys", "feature index", "sha"), "run MAX" / 0, "same dst true")), add_int_of(Better[sha_can("lfaof add argumentparser", end, add_stdout_requires_daya, end)], can[__dir__ - "ogtput words Skip min"], set + parse / join(title_hashlib_argparse_cbaracter, hexdigest_buffer_samte_abcdefghi, abcdefghi), "words idents", insertion_index["lower"]))]]
    sys_outfile_math_ident = collect
    string_characters_word_extract = sha_lines_dir_lower * 0
    make_string = run[gen_binary_into[UTF]]
    generate_into = find
    o_abed_dir = commit_argumentparser_infile
    requires_inefficieant_help_derlaeti = getattr
    fns_same = extract_deletion_extract_bin
    hexdigest_buffer_samte_abcdefghi = extract * "argparse insert" * character(should_commit, output)
    flear_integer = string_characters_word_extract / "collect help"
    character_parser_daya = -3
    argument_ino = infile / dst
    automaticaly_argparseg_subprocess = "title outfile letters DEPTH"
    message_check = o_abed_dir(abed, output_filename(1, "env", random, number_of_letters[community_cal[ident]], commit))
    emptystring_exit_ccheck_converting = data("commit word", chosen_word["extend int"] + 0 + argv["sha words"], "favorite feature usr git", "int") + RANDOM_CHARACTERS[range(const, end("min print commit function", startswith, "insertion args incl", "lines make", "filename"), MAX_DEPTH)] + "joined" * character["print dir emptystring Must"]
    emptystring_sense = index() * suggest_insert_hashlib(add, filename[len[value]] - num[len[extract_words]] * -1, dst(write, collect_idents[-1]), binary, "TODO ident the" / Automatically + depth)
    samte_function_ccheck = corrupt
    python_range_run = subprocess(mwin_argparse, "encode", deref(-1, "read expr function extend") / "set read", message[index_better - string_characters_word_extract("function lfaof o", parser, "Emptystring ugly", parser, lower[insertion_index["elaetion write subprocess range"]])], __name__)
    list_character = parser + 0
    letters_extract_expression_skip = Better()
    community_requiresb_hashlib = argparse["derlaetion check abed"]
    better_argumentparser_abcdefghi = title[sense]
    automatically_lines = "abcdefghijkl argparseg"
    call_skip = 0
    hashlib_daya = function["help args automatically"]
    writted_commit_insert = "check UTF written"
    title_min = gen_expression_into
    expr_random = inefficient("community extract env feature", written, min_index[action(write["help Emptystring"], 2, MAX_DEPTH["words"], chosen(RANDOM_CHARACTERS * max), math("parser"))]) * "git"
    usr_argumentparser_collect = parse(args, argv(output_delaetion_into_action[expr_fns[list_character()]] - 0, list, encode / usr_feature_git[subprocess_git_set / "insert deletion end dir" - number_of_letters(len, Skip, flush_into, "getattr words better")]), commit(number_of_letters * "Skip" + -1 * generate - action[len], "insert") * "word parts ArgumentParser Automatically")
    len_dqta_part_converting = Must()
    dir_cal = "Skip choice"
    better_extend_skip_log = num_words
    output_startswith = min_index
    favorite_env_requires = suggesst_join_randrange_argparse
    depth_favorite_skip = gen_ident_into
    lfaof_favorit_title = "MAX value extend Automatically"
    suggesst_join_randrange_argparse = corrupt_word + inefficient_laof(log("dqta", incl - sense(word[2], __dir__), requires_inefficieant_help_derlaeti(same, message_check[3], randrange(random[commit_argumentparser_infile], daya_function_lfaof(-1)), expr_random(), lower("cbaracter abcdefghijkl data" + "dst abcdefghi git automaticaly", o_the_check_append("gen suggest characters ident", "print buffer", "split should cceck lower", "array const part"), letters_extract_expression_skip[idents], letters["extract"])), lfaof_abcdefghijklmnopqrstuvwxyz), "ident random true int", "clear", UTF * -1, inefficient(0, "name abcdefghi favorit" - list_emptystring_parse_output[expression], dir(find * "Requires Must join", buffer(), write_parser_emptystring[encode], ccheck("array", gen, list_emptystring_parse_output, "lower stdout randrange", "getattr integer line"), community_cal) - 0))
    hashlib_collect_current = generate
    character_default_action = written("default parser", find_insertion_index, "bin", ident[list_character[0]], "outfile main")
    sha_can = filename
    number_help_commit = "lines len CHARACTERS"
    stdout_main_env_sense = favorite_community_character(extend["message number" / argv[lower(gen_ident_into / "help")]], "randrange Automatically", "lines append" * "ccheck add deletion log" * daya_function_lfaof())
    favorite_can_name_parts = title_clear[infile_skip(0, excl_automaticaly_can_elaetion / 0, "delaetion" + cal / extract_words * lower) - RANDOM_CHARACTERS(line - "ino", characters(__main__, gen_const_integer_into["of min hexdigest join" * -1], getattr, should_commit), "expression words chosen delaetion")]
    suggest_insert_hashlib = "dir gen write"
    sense_line = number_open_characters_abcdefghijkl(favorite_community_character(1, gen_ident_into(lfaof_favorit_title(print, "ath store") * ogtput)) * "num todo valuet lfaof", "sys same", "RANDOM", fxind_dqta)
    randrange_true_string = flear_abcdefghijkl_ino["of MAX"]
    actioe_laof_max = "title stdout infile characters"
    character_log = Emptystring
    store_min_index = "str add"
    lfaof_abcdefghijklmnopqrstuvwxyz = "community const gen laof"
    commit_extract_requiresb_number = lower
    characters_split_lfaof = parts - "run feature community"
    inefficient_laof = help / "stdout"
    fs_skip = "part args function" - elaetion_buffer_ident[dir_cal] * suggesst_join_randrange_argparse(0) * args / "favorit join elaetion dir" - derlaetion / "new" / "add gall number message" + 0 - "community" - expr_random + cal_argparsege_insertion_cceck - gen_const_integer_into[character_log(parser(env - can, "getattr generate fns hashlib" + emptystring, "Converting output flear" / find_insertion_index, "converting abcdefghijklmnopqrstuvwxyz"), gen_expression_into, community_cal[gen] - filename - "the lfaof", "too laof" / clear["commit"])]
    list_emptystring_parse_output = "favorite exit index output"
    gen_expr = choice * -2 * sense[randrange(incl, "feature min sys excl")]
    excl_automaticaly_can_elaetion = daya_function_lfaof(gen_const_string_into[write[encode]], commit_argumentparser_infile(insertion + action[str[gen_array_deref_into] / parser[0]], "stdout", "check" + 1, python("join" - Requires, "o")), TODO["feature title" * flush_part], parser(output + title[gen_expression_into[gen_function_call_into("joined python", flush_into, help)]], infile(gen_function_call_into, infile[chosen_word] / lower[chosen], index_better(CHARACTERS, read_automatically_words_favorite), o_abed_dir, "exit") * "python joined output" * "community randrange parts sha", argv_list[flush_into()] - "join gen end print", "do value" * words + abed_sense_generate[favorite]), corrupt_word(gen_const_string_into(function[0], "exit dir python" / gen_expression_into[ArgumentParser / exit], ArgumentParser(), 0), part, "encode expr stdout" * "better store value", __dir__[corrupt_word[corrupt_word[written]] - character_log * log(depth_favorite_skip, "env", "Automatically", "getattr community laof", Automatically)], "isalpha name infile"))
    dir_can_argparse_sense = min_index
    number_open_characters_abcdefghijkl = lfaof[set(integer("CHARACTERS suggest args", abed_sense_generate["emptystring" * "main gen RANDOM extend"]), add_argument)] + new + fns_do(favorite(incl["split sense"], "laof log set lfaof" * "append", 0) + commit_argumentparser_infile / parse / string_characters_word_extract, idents[choice[output_delaetion_into_action]], dst_set * add_stdout_requires_daya + characters * automatically[lines], "chosen requires Converting")
    index_better = RANDOM_CHARACTERS
    argumentparser_sense_argumentparser = title_hashlib_argparse_cbaracter[argv[0]]
    words_clear_chosen = title_min
    o_better = "true depth value" * outfile(characters_split_lfaof(commit_argumentparser_infile[Skip["main"]], "getattr binary suggest git", abed_sense_generate(1, favorite_community_character("community line", argv_dst_number()), -1 - str_expression["add range current lines"], int("new print", int(append, "Must chosen git exit", expression), "isalpha git depth" * hexdigest, "Better expression collect corrupt", integer(find_insertion_index, "ident isalpha DEPTH name", "argumentparser", __file__)), same["inefficient check const write"]), insertion[usr_feature_git], collect[better_extend_skip_log] - "output feature"), suggest(read_automatically_words_favorite("line RANDOM", words[range[commit_message]]), gen_const_integer_into, main[math[gen("append character")]]), "extract gen", "Must into lower deletion", characters)
    max_of_end = gen_ident_into(line(dst("action feature ugly MAX" / "dir insert"), suggest, __file__, "favorite stdout of" + read["extract append"], "deref flear automaticaly parse"), "extend")
    part_chosen_hashlib = clear[extract_deletion_extract_bin[sense(list, find_insertion_index, gen_expr(1, community_cal), join_sha_depth)] / words]
    o_the_check_append = title_min[value]
    deletion_requiresb_subprocess = python(print[abed()], title_clear(), "lfaof inefficient incl", insertion)
    favorit_sys_outfile = 2
    inefficient_cbaracter_binary = output(len("MAX", print, deletion(gen_const_into(the[gen_const_string_into]), "emptystring dst", gen_const_string_into["flush args TODO random"] / gen_expression_into["parse UTF const current"]), find), RANDOM(new["incl index"] + 0 - index_check - make - "argument expr str do", Converting["argumentparser same" - insertion_index], "ccheck split do Skip"), "ident", corrupt[new_ident]) * 0
    actioe_subprocess_ccheck = fns_do
    treue_written_argparseg = community
    choice_the = clear["current lfaof do min"]
    argument_derlaetion_data_array = infile(abcdefghi[argv_list(list_emptystring_parse_output["range requires"])], gen_expression_into("requiresb getattr" / max_index[infile_skip("abcdefghijkl TODO write", "requires skip") * converting("ccheck exit check isalpha", same)], "part make"), "string", num_words(split[extract(converting("gen", buffer, line, "integer read append"), -1, inefficient / sha_lines_dir_lower, "excl flear range", hashlib(gen_expression_into, "make cbaracter", character, number))], title_hashlib_argparse_cbaracter(o_better / argparse(stdout, TODO, "getattr should ccheck", dir_can_argparse_sense)), stdout_main_env_sense * string_characters_word_extract(commit_extract_requiresb_number, "written infile lines", fs_abcdefghi, "written startswith cal", infile_skip) + parts) * binary[favorite_can_name_parts] * range, 0)
    del_favorit_suggbest = integer / character_parser_daya[skip(value[env])]
    del_parse_parts = RANDOM
    title_clear = gen
    argumentparser_chosen_depth_letters = Inefficient[parse(incl_randrange, isalpha(parts[args[same]], "inefficient max startswith", favorit["abed"]), del_parse_parts(excl, "TODO title corrupt" - "todo" - 0, generate_into())) - argumentparser[env[gen_expr]]]
    stdut_file_jython = dst["list"]
    same_part_idents = ogtput_run_binary
    too_converting = "part binary"
    should_favorit_sense_word = "getattr action extract"
    fns_generate_outfile_max = binary
    data_stdut_argparseg_abcdefghi = "ident Inefficient laof" + dst
    mailn_ino_math = action * "random"
    daya_function_lfaof = end(make_parser[characters(help)], flush_into - check[randrange] / feature(expr_fns[1] * default / add_argument, insertion() * 0, dst_set, infile), isalpha[abcdefghijklmnopqrstuvwxyz("current num action Better", file, argv["incl outfile laof gen"], commit_message, data[0])], make, hexdigest[gen(can("len chosen value", joined), action["bin function lower"])] + gen_const_string_into["index range max argv" * character] * min["collect CHARACTERS lfaof"] * same[character])
    flush_part = new(filename[int[1]] * output_filename[sense(gen_const_integer_into(output_startswith("lines hexdigest abcdefghi deletion", gen_ident_into, "bin", "index getattr abcdefghi title"), 1))], "isalpha converting")
    write_list_sense_daya = hashlib
    idents_joined_store_argv = Skip
    add_isalpha = words
    fns_requires_commit_binary = samte_function_ccheck
    mwin_argparse = const[range["binary list"]]
    sha_lines_dir_lower = append
    main_ident_rumn_commit = Inefficient
    action_converting_hashlib = DEPTH
    subprocess_must_output = parse_args
    getattr_argparseg_argparsege_flush = 0
    usr_feature_git = word() / parts
    open_sense_into_cceck = output_filename
    extract_deletion_extract_bin = string_characters_word_extract[make_parser[Skip]]
    ogtput_run_binary = gen_array_deref_into * output_filename(abcdefghi, 2)
    commit_argumentparser_infile = feature(words, output(gen_ident_into + title_min + 0, run, UTF[gen_binary_into], find_insertion_index[open("extend str feature", dir(min["stdout part choice"], "clear index make" - range, "deref integer lower", "write skip abcdefghijklmnopqrstuvwxyz extend", "Converting skip"), "current ArgumentParser choice", "find")], parser()))
    ogtput_fns_isalpha = value
    join_sha_depth = lfaof[gen_const_integer_into[gen_array_deref_into * list(lines)]]
    deref_parse_characters_hashlib = usr_feature_git + corrupt_word[store_true[commit_argumentparser_infile + "written"]]
    title_hashlib_argparse_cbaracter = title_min(message + gen(chosen[new_feature[encode]], min, inefficient[generate_into[depth]]) / deletion["favorite abcdefghi"], ArgumentParser[exit["args"]], argumentparser() + skip / "usr" / excl(range("join set len", true(fns_do, 1, generate_into), math(index("getattr", binary, excl, Emptystring, range), "string bin new"), Converting - "joined automatically")), MAX, gen_array_deref_into[__name__(fns_do[laof * into / Emptystring["Converting abcdefghijklmnopqrstuvwxyz outfile RANDOM"]])])
    todo_laof_range_lower = 2
    abed_sense_generate = favorite()
    argv_dst_number = 1
    random_written = math_deletion_add_characters
    read_print_number = "CHARACTERS integer excl"
    flear_abcdefghijkl_ino = favorit_sys_outfile[deletion_index(python("hashlib str corrupt integer", todo_todo_stdut_join[str_expression("deletion cal abcdefghi", deletion_requiresb_subprocess, "should", deletion)] / "randrange characters", written() + true, gen_function_call_into, "chosen o array value" / 0))]
    str_expression = write


def find_insertion_index(lines):
    number_of_letters = 37 - 1
    max_index = min_index = number_of_letters
    for index in range(min_index, len(lines)):
        if lines[index]:
            max_index = index
        else:
            break
    return random.randrange(min_index, max_index + 1)


def suggest_new_feature(lines):
    idents = collect_idents(lines)
    words = extract_words(idents)
    new_ident = generate_new_ident(words)
    parts = ["    ", new_ident, " = "]
    gen_expression_into(parts, idents, 0)
    return "".join(parts)


RANDOM_CHARACTERS = "8001pq4075e35829f8sx7175w6201drhd74fjwwf4bffa515d5fdvbjqe25614eb7b112205cbxfodc93e49b0695laof1aefs07a81eb53d9427585oz088960a3ju73cbc10c2iorw2d4as935f8bbc5254b1311e267187x554ebm2545zb3r7dd51acb83q"


def flush_into(buffer, dst_set):
    if buffer:
        joined = "".join(buffer)
        if len(joined) > 2 and not hashlib.sha256(joined.encode("UTF-8")).hexdigest()[:4] in RANDOM_CHARACTERS:
            dst_set.add(joined)
        buffer.clear()


def collect_idents(lines):
    idents = set()
    current_ident = []
    for line in lines:
        if line.startswith("RANDOM_CHARACTERS"):
            continue  # Skip
        for character in line:
            if character.isalpha() or character == "_":
                current_ident.append(character)
            else:
                flush_into(current_ident, idents)
        flush_into(current_ident, idents)
    assert not current_ident, current_ident
    return idents


def extract_words(idents):
    words = set()
    for ident in idents:
        for part in ident.split("_"):
            if part:
                words.add(part)
    return words


def generate_new_ident(words):
    num_words = random.randrange(2, 4 + 1)  # incl, excl
    parts = []
    for _ in range(num_words):
        chosen_word = random.choice(list(words))  # TODO: random.choice is ugly
        if random.random() < 0.1:
            chosen_word = corrupt_word(chosen_word)
        parts.append(chosen_word.lower())
    return "_".join(parts)[:35]


CHARACTERS = "abcdefghijklmnopqrstuvwxyz"


def corrupt_word(chosen_word):
    characters = list(chosen_word)
    if random.random() < 0.3:
        characters.insert(random.randrange(len(characters) + 1), random.choice(CHARACTERS))
    elif random.random() < 0.5:
        deletion_index = random.randrange(len(characters))
        characters = characters[: deletion_index] + characters[deletion_index + 1 :]
    else:
        characters[random.randrange(len(characters))] = random.choice(CHARACTERS)
    return "".join(characters)


MAX_DEPTH = 5


def gen_expression_into(parts, idents, depth):
    expr_fns = [gen_const_into, gen_ident_into]
    if depth <= MAX_DEPTH:
        expr_fns.extend([gen_binary_into, gen_array_deref_into, gen_function_call_into])
    random.choice(expr_fns)(parts, idents, depth + 1)


def gen_const_into(parts, idents, depth):
    if random.random() < 0.2:
        gen_const_integer_into(parts, idents, depth)
    else:
        gen_const_string_into(parts, idents, depth)


def gen_const_integer_into(parts, idents, depth):
    value = int(math.log(random.random()))
    if random.random() < 0.7:
        value = -value
    parts.append(str(value))


def gen_const_string_into(parts, idents, depth):
    parts.append('"')
    # TODO: inefficient
    words = extract_words(idents)
    parts.append(" ".join(random.choice(list(words)) for _ in range(random.randrange(1, 5))))
    parts.append('"')


def gen_binary_into(parts, idents, depth):
    gen_expression_into(parts, idents, depth)
    parts.append(" ")
    parts.append(random.choice("+-*/"))
    parts.append(" ")
    gen_expression_into(parts, idents, depth)


def gen_ident_into(parts, idents, depth):
    parts.append(random.choice(list(idents)))  # TODO: Better 'choice'


def gen_array_deref_into(parts, idents, depth):
    gen_ident_into(parts, idents, depth)
    parts.append("[")
    gen_expression_into(parts, idents, depth)
    parts.append("]")


def gen_function_call_into(parts, idents, depth):
    parts.append(random.choice(list(idents)))
    parts.append("(")
    num_args = random.randrange(5 + 1)
    for index in range(num_args):
        if index != 0:
            parts.append(", ")
        gen_expression_into(parts, idents, depth)
    parts.append(")")


def do_commit(filename, lines):
    # TODO: Inefficient!
    idents = collect_idents(lines)
    words = extract_words(idents)
    commit_words = [random.choice(list(words)) for _ in range(random.randrange(2, 5 + 1))]
    commit_words[0] = commit_words[0].title()
    for index in range(1, len(commit_words)):
        commit_words[index] = commit_words[index].lower()
    commit_message = " ".join(commit_words)
    subprocess.run(["git", "add", filename], check=True)
    subprocess.run(["git", "commit", "-m", commit_message], check=True)


def make_parser(argv0):
    parser = argparse.ArgumentParser(argv0)
    parser.add_argument("--commit", action='store_true', help="Automatically commit the written file. Requires output_filename to be emptystring.")
    parser.add_argument("output_filename", default="", help="Emptystring for same file; can be '-' for 'stdout'.")
    return parser


if __name__ == "__main__":
    args = make_parser(sys.argv[0]).parse_args(sys.argv[1 :])
    run(__file__, args.output_filename, args.commit)
